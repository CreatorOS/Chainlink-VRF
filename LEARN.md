# Chainlink VRF
In this Quest, we will be building a fun new NFT based project called “BikiniBottomCollectibles”. The main goal of our project will be users of our platform will be able to mint new NFTs. Every time an NFT is minted, a random character from the Sponge Bob Square Pants Universe (A popular children’s cartoon show) will be generated and assigned to our NFT. Our smart contract will generate a Random Number and based on it assign a unique character to each NFT.

The main goal of our project will be to learn how we can generate random numbers in a smart contract, what are the challenges associated with it, and what are their solutions. We will be following a code-explanation format, where I first share the code and then explain it in detail. Try to code it along as you go and don’t forget to have a lot of fun.

# Environment Setup

The various pre-requisites for this project are:

1. Remix IDE => [Remix IDE](https://remix.ethereum.org/) is an online IDE that is very popular with blockchain developers because it enables the writing of smart contracts and deploying them directly to the blockchain from the comfort of your web browser.
2. MetaMask => [MetaMask](https://metamask.io/) is a blockchain wallet that enables the signing of transactions. It is present in form of browser extension in most popular web browsers like Chrome, Brave, Firefox, Opera, etc., and hence is the most popular blockchain wallet used.
3. Account funded with tokens => We will be deploying our smart contract to the Rinkeby testnet. Any form of interaction with the blockchain, except reading data, is done in form of transactions. This includes deploying smart contracts and interacting with the public functions defined in the smart contracts. Each transaction on the blockchain requires us to pay gas in form of the native token of that blockchain. For Rinkeby, you can fund your account with testnet ETH from [here](https://faucet.rinkeby.io/). We will also need testnet LINK tokens that can be received [here](https://faucets.chain.link/rinkeby). The use for LINK token is defined in a later sub-quest.

# The problem with on-chain random numbers.

Blockchain is a decentralized system, wherein every node in the network participates in validating a transaction and producing the required output. When a smart contract is deployed and ran on the blockchain, technically every node in the blockchain network will be executing the code independently and will mark the transaction successful only when the output produced by each of the nodes is the same.

While trying to implement a random number generator in a smart contract, the problem arises when various nodes execute the same code and yet obtain different results. Random number functions are meant to produce different output every time it is executed, but this will cause in transaction failure.

Let’s understand it with a small example. Suppose we define a function as :

```
	function generateRandomNumber() public returns(uint256) {}
```

This function is expected to return a random number every time it is called. When any account executes this function, the code will be run by various nodes present in the blockchain. If the result obtained by every node is the same, then the transaction would be marked as SUCCESS and a value would be returned. But because the function is expected to return a random number, the values from two different execution in different nodes will not match resulting in the transaction being marked as FAILED and no result will be returned. Because of this reason, it becomes very difficult to generate random numbers or perform any operation based on random values in a smart contract.

# The solution to the problem

To solve the problem mentioned above, we depend on a special type of service which is termed Oracle.  In a blockchain, Oracle is a node or service that is not directly connected to the chain and helps is providing data to the blockchain. If the random number is generated by the Oracle, it can send it back to the smart contract as and when return. The oracle ensures that the random number generated for each transaction is unique. Every node executing the smart contract will receive the same random number if they are validating the same transaction. Because of this, all nodes will arrive at the same output and the transaction will be marked as SUCCESS and the value will be returned.

Since Oracle are not a part of the blockchain, if not implemented properly it can become a central point of failure. This may open up vulnerabilities common for most centralized systems. Because of this, it is important to choose the right Oracle to be used. We will be using Chainlink which is by far the best Oracle service provider and also the most used one. Chainlink uses the concept of *keyHash*. A keyHash is a unique value against which the random number is generated. To use the service of Chainlink Oracle, a fee is to be paid in terms of the LINK token. The price for each service on each chain is predetermined.

We will be using Chainlink VRF (Verifiable Random Function) for generating the random number. Various details associated with chainlink VRF across various chains can be found [here](https://docs.chain.link/docs/vrf-contracts/).

# Initiating the project

1. In RemixIDE, we create a new Folder named *BikiniBottomCollectibles *and within it create a new file name *BikiniBottomCollectibles.sol*, which is going to be the smart contract. * *

![](https://qb-content-staging.s3.ap-south-1.amazonaws.com/public/fb231f7d-06af-4aff-bca3-fd51cb633f77/a767d6e8-4229-433b-8583-ad270c78bd84.jpg)

1. Next copy-paste the following code:

```
//SPDX-License-Identifier: Unlicense

pragma solidity 0.6.6;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/token/ERC721/ERC721.sol";

import "https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/VRFConsumerBase.sol";

contract BikiniBottomCollectibles is ERC721, VRFConsumerBase {

    constructor(

        string memory name,

        string memory symbol,

        address _vrfCoordinator,

        address _linkToken,

        bytes32 _keyHash

    )

    VRFConsumerBase(_vrfCoordinator, _linkToken)

    ERC721(name, symbol)

    public {

        

    }

    

    function mint() public {

        

    }

    

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {

        

    }

}
```

	Let’s understand the code:

- The first line is used to define the License of our program. For this tutorial, we have kept it unlicensed, but you can use any other license of your choice like Apache2.0, MIT, etc.
- The *pragma* keyword is used to define the solidity version. Solidity is a programming language that is being developed in a very rapid space and hence we must specify which version we are using. Since we will be using ChianlinkVRF, we are choosing 0.6.6 as the desired version. You can use a higher version as well, but version 0.8.0 and later is still under development at the time of writing this.
- Now we will import the ERC721 contract from OpenZeppelin repositories and the VRFConsumer contract from the smartcontractkit repository. In Remix another smart contract can be imported by just using the link to that smart contract with the *import *keyword. The ERC721 contract will be needed for creating the NFT while the VRFConsumer contract will be needed for getting the random number.
- Now we define our smart contract using the *contract* keyword. Please make sure that the contract name and the file is matching. We using the *is *keyword to inherit the smart contracts we imported.
- Constructor is always the first function that is called when we deploy a smart contract. We take some constructor arguments as parameters. These parameters are:
	- name => The name of the NFT Smart Contract.
	- symbol => The symbol for the NFT.
	- _vrfCoordinator => VRFCoordinator is a smart contract that is used by Chainlink Oracle to generate random numbers. Each chain (mainnet or testnet) has a VRFCoordinator smart contract deployed on it. We have to pass the address to this contract.
	- _linkToken => Because we have to pay the fee for using the Oracle using LINK token, we must accept the address of LINK token in the chain we are deploying to.
	- _keyHash => The keyHash to be used by the oracle.
- We also initialize the constructors of the imported contracts by passing values to them while defining our constructor.
- Finally, we define the *mint* function which will be used to mint new NFTs.
- The fulfillRandomness function is needed by the chainlink oracle as this function will be called once the random number is generated. The function signature is based on the standards set by Chainlink and a similar signature with the same function name should be used.
	- requestId => To generate a random number we request the Chainlink Oracle and each request has a requestId. The Oracle will return the same random number for the same requestId. This is how it ensures that for every execution of the smart contract in different nodes, the same value is returned.
	- randomness => This is the random number that is returned by the Chainlink Oracle.

# Defining Global Variables

We are going to add some global variables.

    bytes32 internal keyHash;

    uint256 internal fee;

    

    uint256 public tokenCounter; 

- keyHash and fee are the global variables that store the keyhash and fee to be used by VRFConsumer smart contract. We initialize the value for these variables inside our constructor by:

keyHash = _keyHash;

fee = 0.1 \* 10\*\*18; // The fee value is based on Chainlink Documentation

tokenCounter = 0;

- tokenCounter => This variable is used to set a unique tokenId for every minted token. It is initialized as 0

string\[\] public characters = \["SpomgeBob", "Squidward", "Patrick Star", "Mr. Krabs", "Plankton"\];

- Next, we define an array of strings which will have name of all the characters. For simplicity we have considered only 5 popular characters from the show.

    string\[\] public character_metadata_url = \[

        "https://gateway.pinata.cloud/ipfs/QmdBBfQPw3Ndk7JjjYCrHzrFXLaTW6gBhpj7MTA721GqwT", 

        "https://gateway.pinata.cloud/ipfs/QmNgaYLKotSEKDmDVwbKAuPraVPWf1EkLVdRZqUnqsFL19", 

        "https://gateway.pinata.cloud/ipfs/QmRk1Dn7Cj9yrvaTmHzyFhksNLyjU7GBWgq9dHbM2wuj79", 

        "https://gateway.pinata.cloud/ipfs/QmXZKLaRtp4XmFFP5DUeq9uMXSy7dkmL1iQPWrhrut81X5", 

        "https://gateway.pinata.cloud/ipfs/QmS4myzV4ECZJs6gzkCojkCKQ51bT2qHifSB7ysRSUXCh1"

    \];

- Now we define an array of strings called *character_metadata_url* that contains the tokenURI. tokenURI is nothing but an URL that points to a JSON object which has the various aspects of the NFT like the character details and a link to the image. This tokenURI is used by NFT Marketplaces like OpenSea to display it. For simplicity purposes, I have already uploaded the images, created the JSON object, uploaded everything to IPFS, and am hardcoding the URI. It is not always necessary to use IPFS for tokenURI and a central source can be used as well.

	

Metadata basically means any associated data which is stored with the NFT and is used to define the NFT. Since storing data in the blockchain is very expensive and more Gas has to be paid, an efficient solution is to store the data in JSON format in some 3rd Party server or IPFS and then store the link to that JSON data in the smart contract.

mapping (bytes32 => address) public requestIdToSender;

mapping (bytes32 => uint256) public requestIdToTokenId;

mapping (uint256 => string) public tokenIdToCharacter;

- Finally, we define three mappings:
	- requestIdToSender => A mapping of type bytes32=>address. It stores the address of the account making a request for a random number. In our case, this will be the account trying to mint a new NFT.
	- requestIdToTokenId => A mapping of type bytes32 => uint256. This mapping stores the TokenId associated with each request after the NFT is minted.
	- tokenIdToCharacter => A mapping of type uint256 => string. This mapping stores the type of character assigned to each NFT.

Putting it all together, the final code will be:

```
//SPDX-License-Identifier: Unlicense

pragma solidity 0.6.6;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/token/ERC721/ERC721.sol";

import "https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/VRFConsumerBase.sol";

contract BikiniBottomCollectibles is ERC721, VRFConsumerBase {

    

    bytes32 internal keyHash;

    uint256 internal fee;

    

    uint256 public tokenCounter; 

    string\[\] public characters = \["SpomgeBob", "Squidward", "Patrick Star", "Mr. Krabs", "Plankton"\];

    string\[\] public character_metadata_url = \[

        "https://gateway.pinata.cloud/ipfs/QmdBBfQPw3Ndk7JjjYCrHzrFXLaTW6gBhpj7MTA721GqwT", 

        "https://gateway.pinata.cloud/ipfs/QmNgaYLKotSEKDmDVwbKAuPraVPWf1EkLVdRZqUnqsFL19", 

        "https://gateway.pinata.cloud/ipfs/QmRk1Dn7Cj9yrvaTmHzyFhksNLyjU7GBWgq9dHbM2wuj79", 

        "https://gateway.pinata.cloud/ipfs/QmXZKLaRtp4XmFFP5DUeq9uMXSy7dkmL1iQPWrhrut81X5", 

        "https://gateway.pinata.cloud/ipfs/QmS4myzV4ECZJs6gzkCojkCKQ51bT2qHifSB7ysRSUXCh1"

    \];

    

    mapping (bytes32 => address) public requestIdToSender;

    mapping (bytes32 => uint256) public requestIdToTokenId;

    mapping (uint256 => string) public tokenIdToCharacter;

    

    constructor(

        string memory name,

        string memory symbol,

        address _vrfCoordinator,

        address _linkToken,

        bytes32 _keyHash

    )

    VRFConsumerBase(_vrfCoordinator, _linkToken)

    ERC721(name, symbol)

    public {

        

    }

    

    function mint() public {

        

    }

    

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {

        

    }

}
```

# Writing the mint function

The mint function will be:
```
    function mint() public {

        

        bytes32 requestId = requestRandomness(keyHash, fee);

        requestIdToSender\[requestId\] = msg.sender;

        

   }
```

- requestRandomness() is a function imported from the VRFConsumer Smart contract we inherited. This function takes the keyHash and fee as a parameter and returns a unique requestId. This requestId will be later used to refer to a corresponding random number generated by the oracle.
- We store the account by calling the mint function in the requestIdToSender mapping. The msg.sender keyword returns the account calling the function.

# Writing the fullfillRandomness function

The fulfillRandomness() function will be called by the Oracle after the random number is generated. In this function we will be coding the main logic to find the character to be assigned and mint the NFT. The code for this function is:
```
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {

        address characterOwner = requestIdToSender\[requestId\];

        uint256 newItemId = tokenCounter;

        _safeMint(characterOwner, newItemId);

        uint256 charactedId = randomness % 5;

        string memory character = characters\[charactedId\];

        string memory metadata_url = character_metadata_url\[charactedId\];

        tokenIdToCharacter\[newItemId\] = character;

        _setTokenURI(newItemId, metadata_url);

        requestIdToTokenId\[requestId\] = newItemId;

        tokenCounter\+\+;

    }
```
- First, we get the account that made the request by using the requestIdToSender mapping.
- The tokenCounter value will be used for token id. We store the value in newItemId value.
- We call the _safeMint() function inherited from the ERC721 contract for minting the NFT. We pass the account that made the request and the token id for the NFT.
- Since the number of characters defined is 5, in order to find which character to use, we define characterId. randomness%5 returns a number ranging from 0 to 4. We will use this characterId variable to find the character.
- Next, we get the character name in the *character* variable and the token URI in the *metadata_url* variable from the arrays we defined.
- We store the chosen character in tokenIdToCharacter mapping. This stores the character of the NFT on a chain in the smart contract.
- We set the tokenURI using the _setTokenURI() function inherited from the ERC721 contract. We pass the URL obtained from the array in step 5.
- Finally, we increment the tokenCounter variable so that the next minted NFT has a new tokenId. 

# Final Code:
```
//SPDX-License-Identifier: Unlicense

pragma solidity 0.6.6;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/token/ERC721/ERC721.sol";

import "https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/VRFConsumerBase.sol";

contract BikiniBottomCollectibles is ERC721, VRFConsumerBase {

    

    bytes32 internal keyHash;

    uint256 internal fee;

    

    uint256 public tokenCounter; 

    string\[\] public characters = \["SpomgeBob", "Squidward", "Patrick Star", "Mr. Krabs", "Plankton"\];

    string\[\] public character_metadata_url = \[

        "https://gateway.pinata.cloud/ipfs/QmdBBfQPw3Ndk7JjjYCrHzrFXLaTW6gBhpj7MTA721GqwT", 

        "https://gateway.pinata.cloud/ipfs/QmNgaYLKotSEKDmDVwbKAuPraVPWf1EkLVdRZqUnqsFL19", 

        "https://gateway.pinata.cloud/ipfs/QmRk1Dn7Cj9yrvaTmHzyFhksNLyjU7GBWgq9dHbM2wuj79", 

        "https://gateway.pinata.cloud/ipfs/QmXZKLaRtp4XmFFP5DUeq9uMXSy7dkmL1iQPWrhrut81X5", 

        "https://gateway.pinata.cloud/ipfs/QmS4myzV4ECZJs6gzkCojkCKQ51bT2qHifSB7ysRSUXCh1"

    \];

    

    mapping (bytes32 => address) public requestIdToSender;

    mapping (bytes32 => uint256) public requestIdToTokenId;

    mapping (uint256 => string) public tokenIdToCharacter;

    

    constructor(

        string memory name,

        string memory symbol,

        address _vrfCoordinator,

        address _linkToken,

        bytes32 _keyHash

    )

    VRFConsumerBase(_vrfCoordinator, _linkToken)

    ERC721(name, symbol)

    public {

        keyHash = _keyHash;

        fee = 0.1 \* 10\*\*18;

        tokenCounter = 0;

    }

    

    function mint() public returns(bytes32) {

        

        bytes32 requestId = requestRandomness(keyHash, fee);

        requestIdToSender\[requestId\] = msg.sender;

        return requestId;

        

    }

    

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {

        address characterOwner = requestIdToSender\[requestId\];

        uint256 newItemId = tokenCounter;

        _safeMint(characterOwner, newItemId);

        uint256 charactedId = randomness % 5;

        string memory character = characters\[charactedId\];

        string memory metadata_url = character_metadata_url\[charactedId\];

        tokenIdToCharacter\[newItemId\] = character;

        _setTokenURI(newItemId, metadata_url);

        requestIdToTokenId\[requestId\] = newItemId;

        tokenCounter\+\+;

    }

}
```
# Deploying to Rinkeby Testnet

We are going to deploy our contract to the rinkey testnet. Follow the following steps to deploy the contract from within Remix IDE

1. Go to the deploy section from the left navigation bar
2. In the top section on the left side, from the ENVIRONMENT dropdown select “Injected Web3”.
3. If your MetaMask was password locked, you will be asked to enter the password in a MetaMask popup.
4. Once you have connected with metamask, make sure you are connected to the Rinkeby Testnet.
5. In the CONTRACT section, select the BikiniBottomCollectible contract.
6. Before you deploy the contract, you must pass the value to the constructor parameters. Fill in the parameters as follows:

![](https://qb-content-staging.s3.ap-south-1.amazonaws.com/public/fb231f7d-06af-4aff-bca3-fd51cb633f77/716bad19-f954-480a-838b-601de3cbcd61.jpg)

_LINKTOKEN variable stores the address of the Official LINK token in the blockchain we are deploying to. _KEYHASH is a unique value used by Chainlink to generate random numbers. This too is very specific to the blockchain we are deploying to. Both of these values can be found in the official documentation [here](https://docs.chain.link/docs/vrf-contracts/).

1. Click on the *transact *button.
2. MetaMask will pop up asking you to sign the transaction. Sign the transaction.
3. Once the transaction is confirmed, the contract will be deployed and you can see it in the *Deployed Contracts *section.

![](https://qb-content-staging.s3.ap-south-1.amazonaws.com/public/fb231f7d-06af-4aff-bca3-fd51cb633f77/c82282e3-c47d-4507-bf7b-027d292913c2.jpg)

1. Copy the contract address by clicking on the Copy icon on the right side. Now send some LINK tokens from your wallet to this contract address.
2. Once you have sent some LINK tokens to the contract, your contract is ready to mint new NFTs. Expand the contract and click on the *mint *button.
3. Sign the transaction from the MetaMask popup.
4. Once the transaction is confirmed, you have to wait for a couple of minutes for Chainlink Oracle to generate the random number and send it back. The entire process can take 2-3 minutes.
5. You can always check your balance from the balanceOf function present.
6. Once the NFT is successfully minted, you can directly hop to [OpenSea](https://testnets.opensea.io/account) and view your new-minted NFT here.

Keep minting new NFTs unless you have at least one representing all the 5 characters and have fun.

# Conclusion

In this quest, we learned how to use ChainlinkVRF to generate random numbers. We learned the challenges associated with using Random numbers in a smart contract and how Chainlink Oracle helps us solve that issue. We also build an NFT project and deployed it to the Rinkeby testnet.

In the end, here is a small challenge for you guys. Try to use the newly acquired skill of generating random numbers on the blockchain to build a fun game of your own. This can be a Dice game where awards are owned based on the result obtained by rolling a pair of dice.
